from fastapi import FastAPI, HTTPException, Query, BackgroundTasks
import logging
import requests
from typing import List, Dict, Any, Optional

from services.gmv.campaign_creative_detail import GMVCampaignCreativeDetailReporter, _flatten_creative_report
from services.gmv.campaign_product_detail import GMVCampaignProductDetailReporter, _flatten_product_report

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI(
    title="TikTok Reporting API",
    description="API to fetch and process performance data from TikTok GMV Max.",
    version="1.2.0"
)

def process_report_and_callback(context: Dict[str, Any]):
    """
    This function runs in the background. It fetches, flattens, and then
    sends the data back to the Google Apps Script Web App.
    """
    job_id = context["job_id"]
    task_id = context["task_id"]
    task_type = context["task_type"]
    callback_url = context["callback_url"]
    
    logger.info(f"[Job ID: {job_id}] Background task started for type: {task_type}.")

    # -------------------------------------------------------------------------------------
    # Hàm gửi thông tin progress
    def send_progress_update(status: str, message: str, progress: int):
        """Gửi một payload cập nhật tiến trình về callback URL."""
        try:
            progress_payload = {
                "job_id": job_id,
                "status": status, # Sẽ là "RUNNING"
                "message": message,
                "progress": progress
            }
            logger.info(f"[Job ID: {job_id}] Sending progress: {message}")
            requests.post(callback_url, json=progress_payload, timeout=15)
        except requests.exceptions.RequestException as e:
            logger.warning(f"[Job ID: {job_id}] Could not send progress update: {e}")
    # -------------------------------------------------------------------------------------

    try:
        send_progress_update(status="RUNNING", message="Server đã nhận request, bắt đầu khởi tạo...", progress=0)
        # 1. Select the correct reporter and flattening function
        if task_type == "creative":
            reporter = GMVCampaignCreativeDetailReporter(
                access_token=context["access_token"],
                advertiser_id=context["advertiser_id"],
                store_id=context["store_id"],
                progress_callback=send_progress_update
            )
            flatten_function = _flatten_creative_report
        elif task_type == "product":
            reporter = GMVCampaignProductDetailReporter(
                access_token=context["access_token"],
                advertiser_id=context["advertiser_id"],
                store_id=context["store_id"],
                progress_callback=send_progress_update
            )
            flatten_function = _flatten_product_report
        else:
            raise ValueError("Invalid task type specified.")

        # 2. Fetch the raw data
        raw_data = reporter.get_data(context["start_date"], context["end_date"])
        logger.info(f"[Job ID: {job_id}] Successfully fetched raw data.")

        # 3. Flatten the data
        flattened_data = flatten_function(raw_data, context)
        logger.info(f"[Job ID: {job_id}] Successfully flattened into {len(flattened_data)} rows.")

        # 4. Prepare payload for the callback
        callback_payload = {
            "job_id": job_id,
            "task_id": task_id,
            "status": "SUCCESS",
            "data": flattened_data
        }

    except Exception as e:
        logger.error(f"[Job ID: {job_id}] Error during data processing: {e}", exc_info=True)
        callback_payload = { "job_id": job_id, "task_id": task_id, "status": "FAILED", "error_message": str(e), "data": [] }

    # 5. Send the flattened data back to the Apps Script Web App
    try:
        logger.info(f"[Job ID: {job_id}] Sending flattened data to callback URL: {callback_url}")
        response = requests.post(callback_url, json=callback_payload, timeout=60)
        response.raise_for_status()
        logger.info(f"[Job ID: {job_id}] Callback sent successfully.")
    except requests.exceptions.RequestException as e:
        logger.error(f"[Job ID: {job_id}] Failed to send callback to Apps Script: {e}", exc_info=True)


# --- API Endpoint ---

@app.get("/reports/create-job", tags=["Async Jobs"])
def create_report_job(
    background_tasks: BackgroundTasks,
    # Task definition
    task_type: str = Query(..., description="Type of the report. Must be 'creative' or 'product'."),
    callback_url: str = Query(..., description="The Google Apps Script Web App URL."),
    job_id: str = Query(..., description="A unique ID for this job, generated by the client."),
    task_id: str = Query(..., description="The overall Task ID from Google Apps Script."),

    # Auth and IDs
    access_token: str = Query(..., description="Tiktok access token"),
    advertiser_id: str = Query(..., description="Ad account ID"),
    store_id: str = Query(..., description="Shop ID"),
    # Date Range
    start_date: str = Query(..., description="Start date in YYYY-MM-DD format"),
    end_date: str = Query(..., description="End date in YYYY-MM-DD format"),
    # Optional context for enriching data
    advertiser_name: Optional[str] = Query(None, description="Advertiser name for data enrichment."),
    store_name: Optional[str] = Query(None, description="Store name for data enrichment.")
):
    """
    Creates a background job to fetch and flatten report data.
    Responds immediately and sends the data later to the callback_url.
    """
    logger.info(f"Received async job request. Job ID: {job_id}, Type: {task_type}")
    if task_type not in ["creative", "product"]:
        raise HTTPException(status_code=400, detail="Invalid 'task_type'.")

    # Group all params into a context dictionary to pass to the background task
    context = {
        "task_type": task_type, "callback_url": callback_url, "job_id": job_id, "task_id": task_id,
        "access_token": access_token, "advertiser_id": advertiser_id, "store_id": store_id,
        "start_date": start_date, "end_date": end_date,
        "advertiser_name": advertiser_name, "store_name": store_name
    }
    
    background_tasks.add_task(process_report_and_callback, context)

    return {
        "status": "processing",
        "job_id": job_id,
        "message": "Job accepted. Data will be fetched, flattened, and sent to the callback URL."
    }
    
import uvicorn
from pyngrok import ngrok
if __name__ == "__main__":
    # uvicorn.run("test:app", host = "0.0.0.0", port = 8001)
    port = 8001
    
    try:
        # Mở một tunnel HTTP tới cổng 8001

        public_url = ngrok.connect(port, "http")
        print("="*50)
        print(f" * Ngrok tunnel đang chạy tại: {public_url}")
        print(f" * Uvicorn đang chạy trên http://127.0.0.1:{port}")
        print("="*50)
        
        # Chạy uvicorn. Lưu ý: truyền đối tượng 'app' trực tiếp
        uvicorn.run(app, host="0.0.0.0", port=port)
        
    except Exception as e:
        print(f"Lỗi: {e}")
    finally:
        # Ngắt kết nối ngrok khi ứng dụng dừng
        ngrok.disconnect(public_url.public_url)
        print("Đã đóng kết nối ngrok.")